#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Cells tutorial
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Section

Introduction
\layout Subsection

What's cells?
\layout Standard

Cells is a Common Lisp library that extends the language, and in particular
 its object system, to let you write dataflow-driven programs.
 What does this mean? This means that the flow of control of the program
 depends no more on the sequence of function/method calls, but on the data.
 Cells lets you specify the dependence beetwen different slots
\begin_inset Foot
collapsed false

\layout Standard

A slot is the Common Lisp equivalent of a class instance variable in other
 languages
\end_inset 

 in a family of classes.
 Once these constraints have been registered, the cells system will take
 care of them, and will recalculate a value when some data on which it depends
 has changed.
 As a consequence, the programmer just has to tell the system the 
\emph on 
relationship 
\emph default 
between the data, the burden of maintaining them true is handled automatically
 by cells.
 
\layout Subsection

How could it improve your programs?
\layout Standard

Cells may not be the panacea of programming, but it sure helps a lot in
 contexts where keeping a set of values consistent is crucial.
 A particular set of applications where this is important are graphical
 applications
\begin_inset Foot
collapsed false

\layout Standard

See the cells-gtk project: 
\begin_inset LatexCommand \htmlurl{http://common-lisp.net/project/cells-gtk}

\end_inset 


\end_inset 

, where you need to maintain consistency between what the user sees and
 the real values held by the program in its internal data structures.
 An example is the state of the 'Cut' menu entry in an editor: it is usually
 clickable when the user has selected a piece of text and not clickable
 in all the other cases.
 In a normal application, to achieve this behavior you would need to track
 all the methods and all the user actions that could modify the region of
 text currently being selected, and add activate/disactivate calls in all
 those places to keep the menu entry in a consistent state.
 With cells, you just need to tell the system that the state of the menu
 depends on the length of the current text selection: if the length is 0
 then the state is 'deactivated', else it is 'activated'.
 Now you can safely work on the rest of the application ignoring the state
 of the menu: it will be automatically recalculated every time the length
 of the current selection varies.
 Moreover, everything relating to the menu entry is placed near its definition,
 and not scattered across different functions/methods.
\layout Section

Installation
\layout Standard

The installation is quite simple once you have a working Common Lisp system.
 Here I will assume that you've got a working copy of SBCL
\begin_inset Foot
collapsed true

\layout Standard


\begin_inset LatexCommand \htmlurl[SBCL]{http://www.sbcl.org}

\end_inset 


\end_inset 

.
 First of all, download cells: you can get the latest version at 
\begin_inset LatexCommand \htmlurl{http://common-lisp.net/cgi-bin/viewcvs.cgi/cells/?root=cells}

\end_inset 

.
 Then enter the directory ~/.sbcl/site and unpack cells:
\layout LyX-Code

$ cd ~/.sbcl/site
\layout LyX-Code

$ tar -zxvf ~/cells.tar.gz
\layout Standard

Now be sure that ASDF will be able to find it:
\layout LyX-Code

$ cd ~/.sbcl/systems
\layout LyX-Code

$ for a in `find ~/.sbcl/site/cells/ -name 
\begin_inset Quotes eld
\end_inset 

*.asdf
\begin_inset Quotes erd
\end_inset 

` 
\backslash 

\begin_deeper 
\layout LyX-Code

do ln -sf $a .
 
\backslash 

\end_deeper 
\layout LyX-Code

done
\layout Standard

After that, start SBCL and evaluate the following expressions:
\layout LyX-Code

> (require :asdf)
\layout LyX-Code

\layout LyX-Code

NIL
\layout LyX-Code

> (asdf:oos 'asdf:load-op :cells)
\layout LyX-Code

(some output will follow)
\layout Standard

If everything went right cells should be up and running.
\layout Section

Our first cells program
\layout Subsection

The program
\layout Standard

Write the following piece of code in a file named hello-cells.lisp:
\layout LyX-Code

(defmodel hello-cells ()
\layout LyX-Code

  ((num :accessor num :initarg :num :initform (c-in 0))
\layout LyX-Code

   (square-num :accessor square-num 
\layout LyX-Code

               :initform (c? (* (num self) (num self))))))
\layout LyX-Code

\layout LyX-Code

(defun hello ()
\layout LyX-Code

  (let ((h (make-instance 'hello-cells)))
\layout LyX-Code

    (dolist (n '(10 20 30 40 50 60 60))
\layout LyX-Code

      (setf (num h) n)
\layout LyX-Code

      (format t "num is ~a and square-num is ~a~%" (num h) (square-num h)))))
\layout Standard

Now start the SBCL interpreter in the same directory and evaluate the following:
\layout LyX-Code

> (asdf:oos 'asdf:load-op :cells)
\layout LyX-Code

...
\layout LyX-Code

> (use-package :cells)
\layout LyX-Code

T
\layout LyX-Code

> (load 
\begin_inset Quotes eld
\end_inset 

hello-cells.lisp
\begin_inset Quotes erd
\end_inset 

)
\layout LyX-Code

...
\layout LyX-Code

T
\layout LyX-Code

> (hello)
\layout LyX-Code

num is 10 and square-num is 100
\layout LyX-Code

num is 20 and square-num is 400
\layout LyX-Code

num is 30 and square-num is 900
\layout LyX-Code

num is 40 and square-num is 1600
\layout LyX-Code

num is 50 and square-num is 2500
\layout LyX-Code

num is 60 and square-num is 3600
\layout LyX-Code

num is 60 and square-num is 3600
\layout LyX-Code

NIL
\layout Standard

What happens within the function 'hello'? First, an object of type hello-cells
 is created.
 After that the program iterates over the contents of the list '(10 20 30
 40 50 60 60), and every number is used to set the num slot of the object
 h.
 Then the num slot is printed together with the slot square-num.
 The printed value of the slot num gives us no surprise: it has the value
 we gave it.
 This doesn't hold for the slot square-num, though: we never gave it a value
 within the loop, but it always holds the square of the slot num! This is
 just cells working for us: we told the system that the relation
\layout LyX-Code


\begin_inset Formula $num*num=squarenum$
\end_inset 


\layout Standard

must hold, and every time num changes, the expression (* (num self) (num
 self)) is re-evaluated.
 Note that the relation isn't a mathematical equation: you can't change
 square-num and expect to find its square root in num.
\layout Subsection

The program line-by-line
\layout Standard

Lets now analyze the program.
 The very first line uses the construct defmodel:
\layout LyX-Code

(defmodel hello-cells ()
\layout Standard

defmodel is very similar to defclass and everything valid in a defclass
 construct is valid within defmodel
\begin_inset Foot
collapsed false

\layout Standard

defmodel is a layer built on top of defclass
\end_inset 

.
 The main difference is that all the slots defined within it will be tracked
 by cells, except slots that are explicitly declared to be ignored by the
 system by specifying :cell nil in the definition.
\layout LyX-Code

((num :accessor num :initarg :num :initform (c-in 0))
\layout Standard

Here we define the slot num as we would do within a standard class declaration.
 The difference is in its initialization expression: instead of the number
 0 we have (c-in 0).
 Why? (c-in <expr>) is a construct that tells cells that the value of num
 may be changed, so whenever it does change a re-evaluation of all the slots
 that depend on it must be triggered.
 If we did just write 0 instead of (c-in 0) a runtime error would have been
 raised during the execution of (setf (num h) ...).
 So, when a slot is writable it must be signalled to cells with the (c-in
 ...) construct.
 This is necessary to let cells do some optimizations like avoiding to remember
 dependencies on slots that will never change.
 Slots initialized with c-in are usually called 
\begin_inset Quotes eld
\end_inset 

input cells
\begin_inset Quotes erd
\end_inset 

.
\layout LyX-Code

(square-num :accessor square-num 
\layout LyX-Code

            :initform (c? (* (num self) (num self))))))
\layout Standard

Now we define the slot square-num.
 There are two things to note here: (c? <expr>) and 'self'.The first is a
 construct that says: 
\begin_inset Quotes eld
\end_inset 

To calculate the value of square-num, evaluate the expression <expr>
\begin_inset Quotes erd
\end_inset 

.
 Within (c? ...) the variable self is bound to the object itself.
 (c? ...) automatically tracks any dependency, in this case the dependency
 on the value of num: when num changes, (* (num self) (num self)) will be
 re-evaluated.
 Slots initialized with c? are called 
\begin_inset Quotes eld
\end_inset 

ruled cells
\begin_inset Quotes erd
\end_inset 

.
\layout LyX-Code

(let ((h (make-instance 'hello-cells)))
\layout Standard

Here we use the function (make-instance <model-name> 
\emph on 
args*
\emph default 
), to create an object of type <model-name>, in this case hello-cells, as
 we would do to instantiate a normal class.
 You could specify an initial value for num now: 
\layout LyX-Code

(let ((h (make-instance 'hello-cells :num (c-in 50))))
\layout Standard

Note that you 
\emph on 
must
\emph default 
 repeat the (c-in ...) construct.
 This is because the behavior of the slot (input cell, constant, ruled cell)
 is decided on a per instance basis, not on a per class basis.
 This means that, in our example, we could have two objects of type hello-cells,
 one where the slot num is settable and one where it is has a constant value.
 When an object is created, all the values of its slots are computed for
 the first time, in this case the expression (* (num self) (num self)) is
 evaluated and the value given to the slot square-num.
\layout LyX-Code

(setf (num h) n)
\layout Standard

This expression sets the value of the slot num to n.
 This is when cells comes into action: square-num depends on num, so (*
 (num self) (num self)) is re-evaluated after n has changed.
\layout LyX-Code

(format t "num is ~a and square-num is ~a~%" (num h) (square-num h))
\layout Standard

Finally, we print the values of the two slots and discover that the value
 of square-num is correctly the square of num.
\layout Standard

As a side note, you can reset the cells system by calling (cell-reset):
\layout LyX-Code

> (cells-reset)
\layout LyX-Code

NIL
\layout Standard

This could be necessary after an error has corrupted the system and cells
 doesn't seem to work correctly anymore.
 It's also a good practice to reset the system before running code that
 uses cells.
\layout Section

The family system
\layout Standard

Objects whose type have been defined using defmodel can be organized in
 families.
 A family is a tree of model instances (
\emph on 
not
\emph default 
 of model classes!) that can reference each other using the functions (fm-other
 ...), (fm^ ...) and others.
 You can specify the family tree at object creation time passing a list
 of children to the argument :kids.
 Alternatively, you can access the slot .kids (automatically created by defmodel)
 and set it at runtime to change the family components.
 .kids is, by default, a slot of type c-in, and you can access it through
 the method (kids object).
 You can change the .kids slot to be of a type other than c-in as you could
 do with any other slot.
 To access the members of a family you can give them a name with the argument
 :md-name and then reference them by their name.
 Another way to access them is through their type: you could say, for example,
 
\begin_inset Quotes eld
\end_inset 

give me all the successors of type my-type
\begin_inset Quotes erd
\end_inset 

.
 To use these features your models must inherit from the model 'family'.
 Models that inherit from family have also a .value slot associated, which
 you can access through the method (value self)
\begin_inset Foot
collapsed false

\layout Standard

In older releases of cells you had to use (md-value self) instead
\end_inset 

.
 The following example shows some of these things in action:
\layout LyX-Code

(defmodel node (family)
\layout LyX-Code

  ((val :initform (c-in nil) :initarg :val)))
\layout LyX-Code

\layout LyX-Code

(defun math-op-family ()
\layout LyX-Code

  (let ((root
\layout LyX-Code

         (make-instance
\layout LyX-Code

          'node
\layout LyX-Code

          :val (c? (apply #'+ (mapcar #'val (kids self))))
\layout LyX-Code

          :kids
\layout LyX-Code

          (c?
\layout LyX-Code

            (the-kids
\layout LyX-Code

              (make-kid 'node :md-name :n5 :val (c-in 5))
\layout LyX-Code

              (make-kid
\layout LyX-Code

               'node
\layout LyX-Code

               :val (c? (apply #'* (mapcar #'val (kids self))))
\layout LyX-Code

               :kids
\layout LyX-Code

               (c?
\layout LyX-Code

                 (the-kids
\layout LyX-Code

                  (make-kid 'node :md-name :n7 :val (c-in 7))
\layout LyX-Code

                  (make-kid 'node :md-name :n9 :val (c-in 9))))))))))  
 
\layout LyX-Code

    (format t "value of the tree is ~a~%" (val root))
\layout LyX-Code

    (setf (val (fm-other :n7 :starting root)) 10)
\layout LyX-Code

    (format t "new value of the tree is ~a~%" (val root)))) 
\layout Standard

Write it in a file (in this case hello-cells.lisp) and load it:
\layout LyX-Code

> (load 
\begin_inset Quotes eld
\end_inset 

hello-cells.lisp
\begin_inset Quotes erd
\end_inset 

)
\layout LyX-Code

T
\layout LyX-Code

> (math-op-family)
\layout LyX-Code

value of the tree is 68
\layout LyX-Code

new value of the tree is 95
\layout LyX-Code

NIL
\layout Standard

Lets' see the most important parts of the program:
\layout LyX-Code

(defmodel node (family)
\layout LyX-Code

  ((val :initform (c-in nil) :initarg :val)))
\layout Standard

Here we define the model node: we plan to build a family of nodes, so we
 inherit from the model family.
 The slot val will contain the value of the node.
\layout LyX-Code

(make-instance 
\layout LyX-Code

 'node
\layout LyX-Code

 :val (c? (apply #'+ (mapcar #'val (kids self))))
\layout Standard

Now we create the main node: its value is defined as the sum of all its
 children values.
 To get the children list we use the method (kids self).
\layout LyX-Code

:kids
\layout LyX-Code

(c?
\layout LyX-Code

  (the-kids
\layout Standard

We specify the children list using the :kids argument.
 the-kids builds a list of children using the following arguments.
 the-kids also removes nil kids and if an argument is a list then it is
 flattened, e.g.
 (the-kids (list k1 (list (list k2 nil) k3))) will return a list with the
 kids k1, k2 and k3.
\layout LyX-Code

(make-kid 'node :md-name :n5 :val (c-in 5))
\layout Standard

This is the first child of the main node: we give it a name with the :md-name
 argument to reference the node through it in the future.
 To create an instance of a model intended to be a child you must specify
 to make-instance its parent through the argument :fm-parent.
 make-kid does this for us passing self as the parent.
\layout LyX-Code

(make-kid
\layout LyX-Code

 'node
\layout LyX-Code

 :val (c? (apply #'* (mapcar #'val (kids self))))
\layout LyX-Code

 :kids
\layout LyX-Code

 (c?
\layout LyX-Code

   (the-kids
\layout LyX-Code

     (make-kid 'node :md-name :n7 :val (c-in 7))
\layout LyX-Code

     (make-kid 'node :md-name :n9 :val (c-in 9)))))
\layout Standard

The second child of the main node has two children and its value is the
 product of their values.
\layout LyX-Code

(format t "value of the tree is ~a~%" (val root))
\layout LyX-Code

(setf (val (fm-other :n7 :starting root)) 10)
\layout LyX-Code

(format t "new value of the tree is ~a~%" (val root))))
\layout Standard

The body of the function prints the value of the tree, and through the output
 you can see that it depends correctly on the values of its children.
 Then we change the value of the node named :n7 and see that the new output
 has changed accordingly.
 (fm-other <member-name> <starting-point>) searches the family tree starting
 from <starting-point>, and returns the object named <member-name>.
 If it is not found, and error is raised.
 <starting-point> is optional, and it defaults to 'self'.
 We used fm-other outside of a defmodel, so there is no self and we must
 supply a starting point.
\layout Section

Defining an observer
\layout Standard

Cells lets you define a function to execute immediately after a c-in slot
 is modified.
 This function is called an 
\begin_inset Quotes eld
\end_inset 

observer
\begin_inset Quotes erd
\end_inset 

.
 To define it, use the defobserver construct:
\layout LyX-Code

(defobserver <slot-name> (&optional (<self> self) 
\layout LyX-Code

                                    (<new-value> old-value)
\layout LyX-Code

                                    (<old-value> new-value)
\layout LyX-Code

                                    (<old-value-boundp> old-value-boundp))
\layout LyX-Code

  <function-body>)
\layout Standard

This function will be executed every time the slot <slot-name> of an object
 of type <model-name> is modified.
 <old-value> will hold the previous value of the slot, <new-value> the new
 one and <old-value-boundp> will be nil if this is the first time the slot
 gets a value and t otherwise.
 If not given, <self>, <new-value>, <old-value> and <old-value-boundp> will
 default to 'self', 'new-value', 'old-value' and 'old-value-bound-p'.
 In older releases of cells defobserver was called def-c-output.
\layout Standard

Suppose we want to log all the values that the num slot assumes: we can
 do this defining an observer function.
 Add the following lines to hello-cells.lisp:
\layout LyX-Code

(defobserver num ((self hello-cells))
\layout LyX-Code

  (format t 
\begin_inset Quotes eld
\end_inset 

new value of num is: ~a~%
\begin_inset Quotes erd
\end_inset 

 new-value))
\layout Standard

Now reload the file and try running (hello) again:
\layout LyX-Code

> (load 
\begin_inset Quotes eld
\end_inset 

hello-cells.lisp
\begin_inset Quotes erd
\end_inset 

)
\layout LyX-Code

T
\layout LyX-Code

> (hello)
\layout LyX-Code

new value of num is: 0
\layout LyX-Code

new value of num is: 10
\layout LyX-Code

num is 10 and square-num is 100
\layout LyX-Code

new value of num is: 20
\layout LyX-Code

num is 20 and square-num is 400
\layout LyX-Code

new value of num is: 30
\layout LyX-Code

num is 30 and square-num is 900
\layout LyX-Code

new value of num is: 40
\layout LyX-Code

num is 40 and square-num is 1600
\layout LyX-Code

new value of num is: 50
\layout LyX-Code

num is 50 and square-num is 2500
\layout LyX-Code

new value of num is: 60
\layout LyX-Code

num is 60 and square-num is 3600 
\layout LyX-Code

num is 60 and square-num is 3600
\layout LyX-Code

NIL
\layout Standard

As you can see from the output, every time we set (num h) with a different
 value, the action previously defined is called.
 This also happens when (num h) is initialized for the first time at object
 creation time.
 You may have noted that when we set (num h) to 60 for the second time,
 the observer function isn't called: this is because when you set a slot
 to a new value that is the same (according to the function eql) as its
 old one, the change isn't propagated because there is no need to propagate
 it: it didn't change! 
\layout Standard

Now look at the following piece of code: 
\layout LyX-Code

(defmodel str-model ()
\layout LyX-Code

  ((str :accessor str :initform (c-in "") :initarg :str)
\layout LyX-Code

   (rev-str :accessor rev-str :initform (c? (reverse (str self))))))
\layout LyX-Code

\layout LyX-Code

(defobserver str ()
\layout LyX-Code

  (format t "changed!~%"))
\layout LyX-Code

\layout LyX-Code

(defun try-str-model ()
\layout LyX-Code

  (let ((s (make-instance 'str-model)))
\layout LyX-Code

    (dolist (l `("Hello!" "Bye" 
\layout LyX-Code

                 ,(concatenate 'string "By" "e") "!olleH"))
\layout LyX-Code

      (setf (str s) l)
\layout LyX-Code

      (format t "str is 
\backslash 
"~a
\backslash 
", rev-str is 
\backslash 
"~a
\backslash 
"~%" 
\layout LyX-Code

              (str s) (rev-str s)))))
\layout Standard

It does nothing new: it constrains rev-str to be the reverse of str, creates
 an instance of str-model and prints some strings together with their reverse.
 It also logs every time it needs to compute the reversed string.
 Note that the second and the third strings of the list are actually equal.
 Lets try to run the code (supposing you wrote it in hello-cells.lisp):
\layout LyX-Code

> (load 
\begin_inset Quotes eld
\end_inset 

hello-cells.lisp
\begin_inset Quotes erd
\end_inset 

)
\layout LyX-Code

T
\layout LyX-Code

> (try-str-model)
\layout LyX-Code

changed!
\layout LyX-Code

changed!
\layout LyX-Code

str is "Hello!", rev-str is "!olleH"
\layout LyX-Code

changed!
\layout LyX-Code

str is "Bye", rev-str is "eyB"
\layout LyX-Code

changed!
\layout LyX-Code

str is "Bye", rev-str is "eyB"
\layout LyX-Code

changed!
\layout LyX-Code

str is "!olleH", rev-str is "Hello!"
\layout LyX-Code

NIL
\layout Standard

The reversed string is calculated 
\emph on 
every
\emph default 
 time we set (str s), even when we're changing it from 
\begin_inset Quotes eld
\end_inset 

Bye
\begin_inset Quotes erd
\end_inset 

 to 
\begin_inset Quotes eld
\end_inset 

Bye
\begin_inset Quotes erd
\end_inset 

.
 But 
\begin_inset Quotes eld
\end_inset 

Bye
\begin_inset Quotes erd
\end_inset 

 and 
\begin_inset Quotes eld
\end_inset 

Bye
\begin_inset Quotes erd
\end_inset 

 are equal! Why do we need to waste time reversing it twice? Because cells
 by default uses eql to test for equality and if two strings aren't the
 same string (i.e.
 they don't have the same memory address) eql considers them to be different.
 The following piece of code shows us another problem: suppose we change
 
\layout LyX-Code

`("Hello!" "Bye" ,(concatenate 'string "By" "e") "!olleH")
\layout Standard

to
\layout LyX-Code

`("Hello!" "Bye" "Bye" "!olleH")
\layout Standard

depending on the Common Lisp implementation you run the program on you'll
 have a different output! Solving the problem is easy, we just need to use
 equal instead of eql as the equality function.
 To supply your own equality function pass it to the :unchanged-if argument
 in the slot definition:
\layout LyX-Code

(str :accessor str :initform (c-in "") :initarg :str 
\layout LyX-Code

     :unchanged-if #'equal)
\layout Standard

Now we get the same expected result on any implementation:
\layout LyX-Code

changed!
\layout LyX-Code

changed!
\layout LyX-Code

str is "Hello!", rev-str is "!olleH"
\layout LyX-Code

changed!
\layout LyX-Code

str is "Bye", rev-str is "eyB"
\layout LyX-Code

str is "Bye", rev-str is "eyB"
\layout LyX-Code

changed!
\layout LyX-Code

str is "!olleH", rev-str is "Hello!"
\layout LyX-Code

NIL
\layout Standard

The equality function must accept two values: the new value of the slot
 and the old one.
\layout Section

Lazy cells
\layout Standard

Ruled cells are evaluated, as we have already seen, at instance creation
 time and after dependent cells change.
 However, you may want to 
\emph on 
not
\emph default 
 evaluate a ruled cell until it is really needed, i.e.
 when the program asks for its value.
 To achieve such a behavior, you can use lazy cells.
 There are three types of them, depending on their laziness:
\layout Enumerate

:once-asked this will get evaluated/observed on initialization, but won't
 be reevaluated immediately if dependencies change, rather only when read
 by application code.
\layout Enumerate

:until-asked this does not get evaluated/observed until read by application
 code, but then it becomes un-lazy, eagerly reevaluated as soon as any dependenc
y changes (not waiting until asked).
\layout Enumerate

:always this isn't evaluated/observed until read, and not reevaluated until
 read after a dependency changes.
\layout Standard

There are two ways in which a cell can be lazy: by not being evaluated immediate
ly after its creation and by not responding to dependencies change.
 In both cases, when the program asks for its value, the lazy cell is evaluated.
 The first type embodies only the second way, the second type only the first
 way and the third type is lazy in both ways.
 The following example shows the initialization phase lazy cells:
\layout LyX-Code

(defmodel lazy-test ()
\layout LyX-Code

  ((lazy-1 :accessor lazy-1 :initform (c-formula (:lazy :once-asked)
\layout LyX-Code

                                        (append (val self) (list '!!))))
\layout LyX-Code

   (lazy-2 :accessor lazy-2 :initform (c_? (val self)))
\layout LyX-Code

   (lazy-3 :accessor lazy-3 :initform (c?_ (reverse (val self))))
\layout LyX-Code

   (val :accessor val :initarg :val :initform (c-in nil))))
\layout LyX-Code

\layout LyX-Code

(defobserver lazy-1 ()
\layout LyX-Code

  (format t "evaluating lazy-1!~%"))
\layout LyX-Code

\layout LyX-Code

(defobserver lazy-2 ()
\layout LyX-Code

  (format t "evaluating lazy-2!~%"))
\layout LyX-Code

\layout LyX-Code

(defobserver lazy-3 ()
\layout LyX-Code

  (format t "evaluating lazy-3!~%"))
\layout LyX-Code

\layout LyX-Code

(defun print-lazies (l)
\layout LyX-Code

  (format t "Printing all the values:~%")
\layout LyX-Code

  (format t "lazy-3: ~a~%" (lazy-3 l))
\layout LyX-Code

  (format t "lazy-2: ~a~%" (lazy-2 l))
\layout LyX-Code

  (format t "lazy-1: ~a~%" (lazy-1 l)))
\layout LyX-Code

\layout LyX-Code

(defun try-lazies ()
\layout LyX-Code

  (let ((l (make-instance 'lazy-test :val (c-in '(Im very lazy!)))))
\layout LyX-Code

    (format t "Initialization finished~%")
\layout LyX-Code

    (print-lazies l)
\layout LyX-Code

    (format t "Changing val~%")
\layout LyX-Code

    (setf (val l) '(who will be evaluated?))
\layout LyX-Code

    (print-lazies l)))
\layout Standard

As usual, load it and run it:
\layout LyX-Code

> (load 
\begin_inset Quotes eld
\end_inset 

hello-cells.lisp
\begin_inset Quotes erd
\end_inset 

)
\layout LyX-Code

T
\layout LyX-Code

> (try-lazies)
\layout LyX-Code

evaluating lazy-1!
\layout LyX-Code

Initialization finished
\layout LyX-Code

Printing all the values:
\layout LyX-Code

evaluating lazy-3!
\layout LyX-Code

lazy-3: (LAZY! VERY IM)
\layout LyX-Code

evaluating lazy-2!
\layout LyX-Code

lazy-2: (IM VERY LAZY!)
\layout LyX-Code

lazy-1: (IM VERY LAZY! !!)
\layout LyX-Code

Changing val
\layout LyX-Code

evaluating lazy-2!
\layout LyX-Code

Printing all the values:
\layout LyX-Code

evaluating lazy-3!
\layout LyX-Code

lazy-3: (EVALUATED? BE WILL WHO)
\layout LyX-Code

lazy-2: (WHO WILL BE EVALUATED?)
\layout LyX-Code

evaluating lazy-1!
\layout LyX-Code

lazy-1: (WHO WILL BE EVALUATED? !!)
\layout LyX-Code

NIL
\layout Standard

As you can see from the code to declare a ruled cell to be lazy you just
 need to use the three constructs (c-formula (:lazy :one-asked) ...), (c_?
 ...) and (c?_ ...) for :once-asked, :until-asked and :always lazy cells, respectively.
 lazy-1 is evaluated immediately, lazy-2 and lazy-3 only when they are needed
 by format.
 After setting (val l), on which all the lazy cells depend, lazy-2 is re-evaluat
ed immediately because it is of type :until-asked, while lazy-1 becomes
 lazy and lazy-3 remains lazy, so these two postpone evaluation until we
 ask for their values in the call to format.
\layout Standard

As a side note, such short names may not be very easy to remember and to
 read, but those constructs are so common that you'll find yourself using
 them a lot, and you'll appreciate their conciseness.
 If you still prefer long descriptive names, though, you can use the c-formula
 construct instead of c?/c_?/c?_ and c-input instead of c-in (see the 
\begin_inset Quotes eld
\end_inset 

Functions & macros reference
\begin_inset Quotes erd
\end_inset 

 section).
\layout Section

Functions & macros reference
\layout Standard

Here follows a quick reference of the main functions and macros.
\layout Subsection

Main
\layout List
\labelwidthstring 00.00.0000

defmodel
\layout LyX-Code

(defmodel <model-name> (<superclass>*)
\layout LyX-Code

  (<slot-definition>*)
\layout LyX-Code

  <other-optional-arguments>)
\layout Standard

(Macro) Defines a new model.
 It has the same structure and the accept the same options of a class definition.
 <slot-definition> accepts the special argument :cell that lets you declare
 what kind of slot it is.
 The default is a normal cell slot.
 Other options include:
\layout Enumerate

:cell nil the slot will be ignored by the constraints-handling system
\layout Enumerate

:cell :ephemeral when an ephemeral slot is changed, everything works as
 with a normal cell, but after the propagation has ended, its value will
 become nil.
 They are useful to model events.
\layout Standard

There are other types of cells (delta, lazy, etc.) not covered here.
\layout List
\labelwidthstring 00.00.0000

c-in
\layout LyX-Code

(c-in <expr>)
\layout Standard

(Macro) Initializes a cell slot with the value expr.
 When a cell slot initialized with c-in changes, dependant cells will be
 recalculated.
 The value of a cell slot initialized with c-in can be setted.
\layout List
\labelwidthstring 00.00.0000

c-input
\layout LyX-Code

(c-input (&rest args) &optional value)
\layout Standard

(Macro) Same as c-in, but it lets specify extra arguments, and value is
 optional.
 If it is not given, the slot will be unbound and any access to it will
 result into an error.
 
\layout List
\labelwidthstring 00.00.0000

c?
\layout LyX-Code

(c? <body>)
\layout Standard

(Macro) Initializes a cell slot with the value of <body>.
 If <body> references input cell slots, it will be recalculated whenever
 those slots change.
 Within c? you have access to the variable self, representing the current
 object
\layout List
\labelwidthstring 00.00.0000

c-formula
\layout LyX-Code

(c-formula (<options>) <body>)
\layout Standard

(Macro) Same as c?, but lets you specify extra options.
 For example, the option :inputp lets you build a cell that behaves like
 a cell initialized with both c? and c-in.
 Another useful option is :lazy that lets you specify the laziness of the
 cell: nil, t, :once-asked, :until-asked or :always.
\layout List
\labelwidthstring 00.00.0000

not-to-be
\layout LyX-Code

(not-to-be <object>)
\layout Standard

(Function) Tells cells to stop handling <object>.
\layout List
\labelwidthstring 00.00.0000

defobserver
\layout LyX-Code

(defobserver <slot-name> (&optional (<self> self) 
\layout LyX-Code

                                    (<new-value> old-value)
\layout LyX-Code

                                    (<old-value> new-value)
\layout LyX-Code

                                    (<old-value-boundp> old-value-boundp))
\layout LyX-Code

  <function-body>)
\layout Standard

(Macro) Defines a function that is called every time the slot <slot-name>
 changes.
 In previous versions of cells it were called def-c-output.
\layout Subsection

Family models
\layout Standard

The following only works for models that inherit from family.
\layout List
\labelwidthstring 00.00.0000

make-part
\layout LyX-Code

(make-part <md-name> <model-name> &rest <args>)
\layout Standard

(Function) Creates an instance of <model-name> with :md-name set to <md-name>.
 <args> are passed to make-instance.
\layout List
\labelwidthstring 00.00.0000

mk-part
\layout LyX-Code

(mk-part <md-name> (<model-name>) &rest <args>)
\layout Standard

(Macro) Same as make-part, but sets the parent to self
\layout List
\labelwidthstring 00.00.0000

the-kids
\layout LyX-Code

(the-kids &rest <kids>)
\layout Standard

(Macro) Builds a list of kids.
 <kids> may contain objects or nested lists of objects.
\layout List
\labelwidthstring 00.00.0000

make-kid
\layout LyX-Code

(make-kid <model-name> &rest <args>)
\layout Standard

(Macro) The same as (make-instance <model-name> <args> :fm-parent self).
\layout List
\labelwidthstring 00.00.0000

kids
\layout LyX-Code

(kids <object>)
\layout Standard

(Method) Gives access to <object>'s children.
\layout List
\labelwidthstring 00.00.0000

kid1,kid2,last-kid
\layout LyX-Code

(kid1 <object>)
\layout LyX-Code

(kid2 <object>)
\layout LyX-Code

(last-kid <object>
\layout Standard

(Function) Gives access, respectively, to <object>'s first, second and last
 child
\layout List
\labelwidthstring 00.00.0000

^k1,^k2,^k-last
\layout LyX-Code

(^k1)
\layout LyX-Code

(^k2)
\layout LyX-Code

(^k-last)
\layout Standard

(Macro) Shortcuts for (kid1 self), (kid2 self) and (last-kid self)
\layout List
\labelwidthstring 00.00.0000

fm-parent
\layout LyX-Code

(fm-parent &optional (<object> self))
\layout Standard

(Method) Gives access to <object>'s parent.
\layout List
\labelwidthstring 00.00.0000

fm-other
\layout LyX-Code

(fm-other <name> &optional (<starting-point> self))
\layout Standard

(Macro) Looks for an object named <name> within <starting-point>'s family.
\layout List
\labelwidthstring 00.00.0000

fm^
\layout LyX-Code

(fm^ <name> &optional (<starting-point> self))
\layout Standard

(Macro) Same as (fm-other <name> (fm-parent <starting-point>)), but doesn't
 search <starting-point> and its children.
\layout List
\labelwidthstring 00.00.0000

fm-kid-typed
\layout LyX-Code

(fm-kid-typed <self> <type>)
\layout Standard

(Function) Finds the first <self>'s child whose type is <type>.
\layout List
\labelwidthstring 00.00.0000

fm-descendant-typed
\layout LyX-Code

(fm-descendant-typed <self> <type>)
\layout Standard

(Function) Finds the first descendant of <self> whose type is <type>
\layout Subsection

Misc
\layout List
\labelwidthstring 00.00.0000

cells-reset
\layout LyX-Code

(cells-reset)
\layout Standard

(Function) Resets the system.
\layout Section

Other resources
\layout Standard

This tutorial just scratched the surface of cells.
 You can find more documentation about cells within the 'doc' directory
 in the source tarball or by looking at the source files within the directories
 'cells-test', 'tutorial' and 'Use Cases'.
 A general overview of cells can be found in the file cells-manifesto.txt
 in the source tarball.
 You can also ask questions about cells on the project's mailing list: 
\begin_inset LatexCommand \htmlurl{http://common-lisp.net/cgi-bin/mailman/subscribe/cells-devel}

\end_inset 


\the_end
